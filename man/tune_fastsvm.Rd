% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune.R
\name{tune_fastsvm}
\alias{tune_fastsvm}
\title{Single Grid Search for FastKernelSurvivalSVM}
\usage{
tune_fastsvm(
  data,
  time_col = "t",
  delta_col = "delta",
  param_grid,
  cv = 5L,
  cores = parallel::detectCores(),
  verbose = 0L,
  refit = TRUE,
  ...
)
}
\arguments{
\item{data}{Training data frame.}

\item{time_col}{Time column name.}

\item{delta_col}{Event column name.}

\item{param_grid}{A named list (or list of lists) of parameters to tune.
Example: \code{list(alpha = c(0.1, 1), rank_ratio = c(0, 1))}.}

\item{cv}{Number of folds (default 5).}

\item{cores}{Number of parallel cores (default: \code{parallel::detectCores()}).}

\item{verbose}{Verbosity level (0 or 1).}

\item{refit}{Logical. If \code{TRUE}, refit model with best params on full data.}

\item{...}{Additional fixed parameters passed to all estimators.}
}
\value{
An object of class \code{"fastsvm_grid"} containing:
  \itemize{
    \item \code{best_params}: A named list of optimal parameters.
    \item \code{best_score}: The best mean cross-validated C-index.
    \item \code{cv_results}: A data frame summarizing the search history.
    \item \code{best_estimator}: The fitted model object (if \code{refit=TRUE}).
  }
}
\description{
Executes a grid search to optimize hyperparameters for a single kernel configuration.
Uses cross-validation to evaluate the C-index.
}
\section{Parallelization Strategy}{

The \code{cores} argument controls how computation is distributed:
\itemize{
  \item \strong{Standard Kernels ("rbf", "linear", etc.):} If the kernel is a string,
        the function uses Python's `GridSearchCV` native parallelism (via `joblib`).
        This is extremely fast and efficient.
        
  \item \strong{Custom R Kernels:} If the kernel is an R function, `scikit-learn`
        cannot parallelize natively (pickle error). In this case, the function
        automatically detects it and uses the \pkg{mirai} package to distribute
        grid candidates across parallel R workers. Each worker runs cross-validation
        for one candidate serially.
}
}

\examples{
\dontrun{
if (reticulate::py_module_available("sksurv") && requireNamespace("mirai", quietly = TRUE)) {
  library(FastSurvivalSVM)
  
  # --- Data Generation ---
  set.seed(42)
  df <- data_generation(n = 200, prop_cen = 0.3)

  # =========================================================================
  # EXAMPLE 1: Standard Kernel (RBF) - Regression Mode (rank_ratio=0)
  # =========================================================================
  # We optimize 'alpha' and 'gamma' using a grid of 3 values each.
  
  grid_rbf <- list(
    kernel = "rbf",
    rank_ratio = 0, # Regression on time
    alpha  = c(0.01, 0.1, 1),
    gamma  = c(0.001, 0.01, 0.1)
  )
  
  res_rbf <- tune_fastsvm(
    data = df, 
    time_col = "tempo", delta_col = "cens",
    param_grid = grid_rbf,
    cv = 3, 
    cores = 2, # Passed to Python's joblib
    verbose = 1
  )
  print(res_rbf)

  # =========================================================================
  # EXAMPLE 2: Custom Kernel in R - Regression Mode
  # =========================================================================
  
  # 1. Define a Kernel Factory (e.g., simple Sum-Product kernel)
  make_sumprod <- function(bias = 0) { 
    force(bias)
    function(x, z) {
      prod(as.numeric(x) * as.numeric(z)) + bias
    }
  }
  
  # 2. Create variants to tune the 'bias' parameter (3 values)
  k_variants <- create_kernel_variants(make_sumprod, bias = c(0, 1, 5))
  
  # 3. Define grid (Tune kernel variant and regularization)
  grid_custom <- list(
    kernel = k_variants,   
    rank_ratio = 0, # Regression on time
    alpha  = c(0.1, 1, 10)     
  )
  
  # 4. Tune (Automatically detects custom kernel -> switches to mirai)
  res_custom <- tune_fastsvm(
    data = df, 
    time_col = "tempo", delta_col = "cens",
    param_grid = grid_custom,
    cv = 3, 
    cores = 2, # Starts 2 background R daemons
    verbose = 1
  )
  print(res_custom)
}
}

}

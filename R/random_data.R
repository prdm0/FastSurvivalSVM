#' Example data generator for testing FastSurvivalSVM
#'
#' This function simulates a right-censored survival dataset from a fixed
#' Weibull model with three covariates. It is intended **only** as a simple
#' helper for examples, unit tests, and reproducible illustrations of
#' \code{FastSurvivalSVM} functionality.
#'
#' The data-generating mechanism is not general-purpose and is not meant to
#' cover arbitrary covariate structures or censoring schemes. The model is
#' hard-coded with three covariates (\code{x1}, \code{x2}, \code{x3}), a
#' Weibull baseline distribution, and a specific nonlinear predictor.
#'
#' @param n Integer. Sample size.
#' @param prop_cen Numeric in \eqn{(0, 1)}. Approximate proportion of
#'   censored observations among the \code{n} generated individuals.
#'
#' @return A \code{data.frame} with the following columns:
#' \describe{
#'   \item{tempo}{Observed time (minimum between event time and censoring time).}
#'   \item{cens}{Event indicator: \code{1} = event, \code{0} = right censoring.}
#'   \item{x1}{Continuous covariate generated from \eqn{N(1, 1^2)}.}
#'   \item{x2}{Continuous covariate generated from \eqn{N(2, 2^2)}.}
#'   \item{x3}{Continuous covariate generated from an exponential distribution
#'             with rate 1.}
#' }
#'
#' @details
#' The true event times \code{time_t} follow a Weibull distribution with
#' shape parameter \code{shape = 2} and scale parameter \code{scale = 5},
#' modified by a nonlinear predictor:
#' \deqn{
#'   \eta = x_1 \log(|x_2|) + 2 \sin(x_3 - x_2)^2,
#' }
#' and the event times are generated via the inverse CDF method:
#' \deqn{
#'   T = \left( -\log(1 - U) \right)^{1/\text{shape}} \times
#'       \text{scale} \times \exp(-\eta),
#' }
#' where \eqn{U \sim \text{Uniform}(0, 1)}.
#'
#' Censoring times are generated by randomly selecting approximately
#' \code{n * prop_cen} individuals and replacing their event time by a
#' uniform draw between the minimum observed \code{time_t} and the
#' individual's own \code{time_t}. For those individuals, the event
#' indicator \code{cens} is set to \code{0}.
#'
#' @examples
#' set.seed(123)
#' df <- data_generation(n = 300L, prop_cen = 0.1)
#' head(df)
#'
#' if (reticulate::py_module_available("sksurv")) {
#'   # Example: using this toy dataset with FastKernelSurvivalSVM
#'   fit <- fastsvm(
#'     data      = df,
#'     time_col  = "tempo",
#'     delta_col = "cens",
#'     kernel    = "rbf",
#'     alpha     = 1,
#'     rank_ratio = 0
#'   )
#'
#'   score(fit, df)
#' }
#'
#' @importFrom stats rnorm rexp runif
#' @export
data_generation <- function(n, prop_cen) {
  if (length(n) != 1L || n <= 0L) {
    stop("`n` must be a positive integer.", call. = FALSE)
  }
  if (length(prop_cen) != 1L || prop_cen <= 0 || prop_cen >= 1) {
    stop("`prop_cen` must be a numeric value in (0, 1).", call. = FALSE)
  }

  n <- as.integer(n)

  # 3 covariates
  x1 <- rnorm(n, mean = 1, sd = 1)
  x2 <- rnorm(n, mean = 2, sd = 2)
  x3 <- rexp(n)  # rate = 1

  # Weibull parameters
  xbeta <- x1 * log(abs(x2)) + 2 * sin(x3 - x2)^2
  shape <- 2
  scale <- 5

  # True event times (without censoring)
  u <- runif(n, 0, 1)
  time_t <- ((-log(1 - u))^(1 / shape)) * scale * exp(-xbeta)

  # Select individuals to be censored and generate censoring times
  n_cens <- floor(n * prop_cen)
  if (n_cens > 0L) {
    ind_cens <- sample.int(n, n_cens, replace = FALSE)
  } else {
    ind_cens <- integer(0L)
  }

  time_gerado <- time_t
  if (length(ind_cens) > 0L) {
    time_gerado[ind_cens] <- runif(
      n = length(ind_cens),
      min = min(time_t),
      max = time_t[ind_cens]
    )
  }

  # Event indicator: 1 = event, 0 = censoring
  cens <- rep(1L, n)
  if (length(ind_cens) > 0L) {
    cens[ind_cens] <- 0L
  }

  dados_g <- data.frame(
    tempo = time_gerado,
    cens  = cens,
    x1    = x1,
    x2    = x2,
    x3    = x3
  )

  dados_g
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune.R
\name{tune_fastsvm}
\alias{tune_fastsvm}
\title{Single Grid Search for FastKernelSurvivalSVM}
\usage{
tune_fastsvm(
  data,
  time_col = "t",
  delta_col = "delta",
  param_grid,
  cv = 5L,
  cores = parallel::detectCores(),
  verbose = 0L,
  refit = TRUE,
  ...
)
}
\arguments{
\item{data}{Training data frame.}

\item{time_col}{Time column name.}

\item{delta_col}{Event column name.}

\item{param_grid}{A named list (or list of lists) of parameters to tune.
Example: \code{list(alpha = c(0.1, 1), rank_ratio = c(0, 1))}.}

\item{cv}{Number of folds (default 5).}

\item{cores}{Number of parallel cores (default: \code{parallel::detectCores()}).}

\item{verbose}{Verbosity level (0 or 1).}

\item{refit}{Logical. If \code{TRUE}, refit model with best params on full data.}

\item{...}{Additional fixed parameters passed to all estimators.}
}
\value{
An object of class \code{"fastsvm_grid"} containing:
  \itemize{
    \item \code{best_params}: A named list of optimal parameters.
    \item \code{best_score}: The best mean cross-validated C-index.
    \item \code{cv_results}: A data frame summarizing the search history.
    \item \code{best_estimator}: The fitted model object (if \code{refit=TRUE}).
  }
}
\description{
Executes a grid search to optimize hyperparameters for a single kernel configuration.
Uses cross-validation to evaluate the C-index.
}
\section{Parallelization Strategy}{

The \code{cores} argument controls how computation is distributed:
\itemize{
  \item \strong{Standard Kernels ("rbf", "linear", etc.):} If the kernel is a string,
        the function uses Python's `GridSearchCV` native parallelism (via `joblib`).
        This is extremely fast and efficient.
        
  \item \strong{Custom R Kernels:} If the kernel is an R function, `scikit-learn`
        cannot parallelize natively (pickle error). In this case, the function
        automatically detects it and uses the \pkg{mirai} package to distribute
        grid candidates across parallel R workers. Each worker runs cross-validation
        for one candidate serially.
}
}

\examples{
\dontrun{
if (reticulate::py_module_available("sksurv") && requireNamespace("mirai")) {
  library(FastSurvivalSVM)
  
  set.seed(42)
  # Generate dummy data
  df <- data.frame(
    time = rexp(100),
    event = rbinom(100, 1, 0.7),
    x1 = rnorm(100), x2 = rnorm(100)
  )

  # --- Example 1: Standard Kernel (RBF) ---
  # Uses Python parallelism (very fast)
  grid_rbf <- list(
    kernel = "rbf",
    alpha  = c(0.1, 1),
    gamma  = c(0.01, 0.1)
  )
  
  res_rbf <- tune_fastsvm(
    data = df, 
    time_col = "time", delta_col = "event",
    param_grid = grid_rbf,
    cv = 3, 
    cores = parallel::detectCores(), # Use all cores
    verbose = 1
  )
  print(res_rbf)

  # --- Example 2: Custom Kernel (Wavelet) ---
  # Uses R parallelism (mirai) automatically
  
  # 1. Define Factory
  make_wav <- function(a=1) { 
    force(a)
    function(x,z) {
      u<-(as.numeric(x)-as.numeric(z))/a
      prod(cos(1.75*u)*exp(-0.5*u^2))
    }
  }
  
  # 2. Create Variants
  wav_vars <- create_kernel_variants(make_wav, a = c(0.5, 2.0))
  
  grid_wav <- list(
    kernel = wav_vars,
    alpha  = c(0.1, 1)
  )
  
  # 3. Tune (cores > 1 activates mirai backend)
  res_wav <- tune_fastsvm(
    data = df, 
    time_col = "time", delta_col = "event",
    param_grid = grid_wav,
    cv = 3, 
    cores = parallel::detectCores(), # Use all cores
    verbose = 1
  )
  print(res_wav)
}
}

}

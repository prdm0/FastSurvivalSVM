% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune.R
\name{grid_kernel}
\alias{grid_kernel}
\title{Create a Kernel Grid or Single Instance (Smart Wrapper)}
\usage{
grid_kernel(func, ...)
}
\arguments{
\item{func}{A bare R function. It must accept at least two arguments named
\code{x} and \code{z} (representing the data vectors), followed by any
hyperparameters you wish to tune.}

\item{...}{Named arguments defining the hyperparameters.
\itemize{
  \item **Vectors:** Will be expanded into a grid (returns a list).
  \item **Scalars:** Will create a single instance (returns the function).
}}
}
\value{
\itemize{
  \item If the expansion results in multiple variants: A named list of kernel functions.
  \item If the expansion results in a single variant: The kernel function itself.
}
}
\description{
This helper simplifies the definition of custom kernels. It serves two purposes:
\enumerate{
  \item **Tuning:** If you provide vectors of parameters, it returns a list of
        kernel variants to be used in \code{\link{tune_random_machines}} or
        \code{\link{tune_fastsvm}}.
  \item **Fixed Instance:** If you provide single values for parameters, it
        returns the single kernel function directly, ready for \code{\link{random_machines}}.
}
}
\details{
This abstracts away the complexity of the "function factory" pattern (closures)
and eliminates the need to manually extract elements from a list when creating
a single kernel.
}
\examples{
# 1. Define the kernel logic
my_wavelet <- function(x, z, A) {
  u <- (as.numeric(x) - as.numeric(z)) / A
  prod(cos(1.75 * u) * exp(-0.5 * u^2))
}

# 2. For Tuning: Create a list of variants (vector input)
#    Returns a list of 3 functions
grid <- grid_kernel(my_wavelet, A = c(0.5, 1, 2))
class(grid) # "list"

# 3. For Fixed Use: Create a single instance (scalar input)
#    Returns the function directly (Smart Return, no [[1]] needed)
k_one <- grid_kernel(my_wavelet, A = 1)
class(k_one) # "fastsvm_custom_kernel" (function)

}

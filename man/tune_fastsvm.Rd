% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune.R
\name{tune_fastsvm}
\alias{tune_fastsvm}
\title{Single Grid Search for FastKernelSurvivalSVM}
\usage{
tune_fastsvm(
  data,
  time_col = "t",
  delta_col = "delta",
  param_grid,
  cv = 5L,
  cores = parallel::detectCores(),
  verbose = 0L,
  refit = TRUE,
  ...
)
}
\arguments{
\item{data}{Training data frame.}

\item{time_col}{Name of the column containing survival times.}

\item{delta_col}{Name of the column containing the event indicator (1=event, 0=censored).}

\item{param_grid}{A named list (or list of lists) of parameters to tune.
\itemize{
  \item For **Standard Kernels**: Provide vectors of values.
        Example: \code{list(kernel="rbf", gamma=c(0.1, 1))}
  \item For **Custom Kernels**: Use \code{\link{grid_kernel}} to generate the kernel list.
        Example: \code{list(kernel=grid_kernel(my_func, A=1:3), alpha=c(0.1, 1))}
}}

\item{cv}{Number of cross-validation folds (default 5).}

\item{cores}{Number of cores to use (defaults to detected cores).}

\item{verbose}{Verbosity level (0 or 1).}

\item{refit}{Logical. If \code{TRUE}, refits the model with the best found parameters on the full dataset.}

\item{...}{Additional arguments passed directly to the estimator (e.g., \code{rank_ratio}, \code{max_iter}).}
}
\value{
An object of class \code{"fastsvm_grid"} containing the best parameters, score, and full CV results.
}
\description{
Executes a grid search with cross-validation to optimize hyperparameters for a
single kernel configuration.
}
\section{Parallelization Strategy}{

The \code{cores} argument controls the parallel backend:
\itemize{
  \item \strong{Standard Kernels} (strings like "rbf", "linear"): Uses Python's
        \code{joblib} (via scikit-learn) for efficient multi-threading.
  \item \strong{Custom R Kernels} (created via \code{\link{grid_kernel}}): Uses
        the \pkg{mirai} package to distribute candidates across R background processes.
}
}

\examples{
\dontrun{
if (reticulate::py_module_available("sksurv") && requireNamespace("mirai", quietly = TRUE)) {
  library(FastSurvivalSVM)
  set.seed(42)

  # --- 1. Prepare Data ---
  # Generating synthetic survival data
  df <- data_generation(n = 200, prop_cen = 0.3)

  # =========================================================================
  # EXAMPLE A: Tuning a Standard Kernel (RBF)
  # =========================================================================
  # We want to tune 'alpha' (regularization) and 'gamma' (kernel width).
  # rank_ratio = 0 implies we are optimizing for Regression (time), not Ranking.

  grid_rbf <- list(
    kernel = "rbf",
    rank_ratio = 0.0,
    alpha  = c(0.01, 0.1, 1.0),
    gamma  = c(0.01, 0.1, 1.0)
  )

  # Automatically uses Scikit-learn parallelism (Python threads)
  res_rbf <- tune_fastsvm(
    data = df,
    time_col = "tempo", delta_col = "cens",
    param_grid = grid_rbf,
    cv = 3,
    cores = parallel::detectCores(),
    verbose = 1
  )
  print(res_rbf)

  # =========================================================================
  # EXAMPLE B: Tuning a Custom R Kernel (Using grid_kernel)
  # =========================================================================

  # 1. Define the kernel function (Simple Sum-Product + Bias)
  my_sumprod <- function(x, z, bias) {
     prod(as.numeric(x) * as.numeric(z)) + bias
  }

  # 2. Define the grid
  #    - 'kernel': use grid_kernel() to vary 'bias' (returns a list of functions)
  #    - 'alpha': standard SVM parameter
  grid_custom <- list(
    kernel = grid_kernel(my_sumprod, bias = c(0, 1, 5)),
    rank_ratio = 0.0,
    alpha  = c(0.1, 1.0)
  )

  # 3. Tune (Automatically switches to mirai for R parallelism)
  res_custom <- tune_fastsvm(
    data = df,
    time_col = "tempo", delta_col = "cens",
    param_grid = grid_custom,
    cv = 3,
    cores = parallel::detectCores(),
    verbose = 1
  )
  print(res_custom)
}
}

}

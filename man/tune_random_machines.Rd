% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune.R
\name{tune_random_machines}
\alias{tune_random_machines}
\title{Multi-Kernel Tuning for Random Machines}
\usage{
tune_random_machines(
  data,
  time_col = "t",
  delta_col = "delta",
  kernel_mix,
  param_grids,
  cv = 5L,
  n_jobs = 1L,
  verbose = 0L,
  ...
)
}
\arguments{
\item{data}{A \code{data.frame} containing training data.}

\item{time_col}{Name of the time column.}

\item{delta_col}{Name of the event column (1=event, 0=censored).}

\item{kernel_mix}{A named list defining the base configuration for each kernel.
Each element should be a list with at least the \code{kernel} parameter.}

\item{param_grids}{A named list of parameter grids corresponding to \code{kernel_mix}.
The names must match the names in \code{kernel_mix}. Each element is a list
of parameters to vary.}

\item{cv}{Number of cross-validation folds (default: 5).}

\item{n_jobs}{Number of parallel jobs for grid search. See guidelines.}

\item{verbose}{Verbosity level (0 or 1).}

\item{...}{Additional fixed parameters passed to all estimators.}
}
\value{
An object of class \code{"random_machines_tune"}, containing the tuning
  results for each kernel.
}
\description{
Orchestrates hyperparameter tuning for multiple kernels simultaneously.
This function allows you to define a list of kernel configurations (similar to
\code{\link{random_machines}}) and a corresponding list of parameter grids,
finding the best hyperparameters for each kernel type.
}
\section{Parallelization Guidelines}{

\itemize{
  \item Use \code{n_jobs = parallel::detectCores()} if ALL kernels in the list are built-in strings (e.g., "rbf", "linear").
  \item Use \code{n_jobs = 1} if ANY kernel in the list is a custom R function.
}
}

\examples{
\dontrun{
if (reticulate::py_module_available("sksurv")) {
  library(FastSurvivalSVM)
  set.seed(42)
  df <- data_generation(n = 200, prop_cen = 0.3)

  # --- 1. Define Base Kernels ---
  make_wav <- function(a=1) { force(a); function(x,z) {
     u<-(as.numeric(x)-as.numeric(z))/a; prod(cos(1.75*u)*exp(-0.5*u^2))
  }}
  
  base_kernels <- list(
    linear  = list(kernel = "linear"),
    rbf     = list(kernel = "rbf"),
    wavelet = list(kernel = make_wav(a=1)) # Initial placeholder
  )

  # --- 2. Define Grids for Tuning ---
  # For custom kernels, use create_kernel_variants in the grid!
  wav_vars <- create_kernel_variants(make_wav, a=c(0.5, 1.0, 2.0))
  
  tuning_grids <- list(
    linear  = list(alpha = c(0.1, 1, 10)),
    rbf     = list(alpha = c(0.1, 1), gamma = c(0.01, 0.1)),
    wavelet = list(alpha = c(0.1, 1), kernel = wav_vars) # Tune 'a' via kernel variants
  )

  # --- 3. Run Tuning ---
  # n_jobs=1 because we have a custom wavelet kernel
  results <- tune_random_machines(
    data = df, time_col = "tempo", delta_col = "cens",
    kernel_mix = base_kernels,
    param_grids = tuning_grids,
    cv = 3, n_jobs = 1, verbose = 1
  )

  # --- 4. Inspect Results ---
  print(results)
  
  # Access best params
  print(results$rbf$best_params)
  
  # Access best 'a' for wavelet
  best_wav <- results$wavelet$best_params$kernel
  cat("Best wavelet 'a':", best_wav$a, "\n")
}
}

}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bagging.R
\name{fastsvm_bagging}
\alias{fastsvm_bagging}
\title{Parallel Bagging for FastKernelSurvivalSVM (Reference Architecture)}
\usage{
fastsvm_bagging(
  data,
  newdata,
  time_col = "t",
  delta_col = "delta",
  kernels,
  B = 100L,
  mtry = NULL,
  beta_kernel = 1,
  beta_bag = 1,
  cores = 1L,
  seed = NULL,
  .progress = TRUE
)
}
\arguments{
\item{data}{A \code{data.frame} containing training data.}

\item{newdata}{A \code{data.frame} containing test data for prediction.}

\item{time_col}{Name of the column with survival times.}

\item{delta_col}{Name of the column with the event indicator (1=event, 0=censored).}

\item{kernels}{A named list of kernel specifications. Each element must be a list 
of arguments to the estimator.}

\item{B}{Integer. Number of bootstrap samples.}

\item{mtry}{Integer or Numeric. Number of variables to randomly sample at each split.
\itemize{
  \item \code{NULL} (default): Use all variables (Standard Bagging).
  \item Integer >= 1: Select exactly \code{mtry} variables.
  \item Numeric < 1: Select \code{mtry} fraction of variables (e.g., 0.5 = 50\%).
}}

\item{beta_kernel}{Numeric. Temperature for kernel selection probabilities.}

\item{beta_bag}{Numeric. Temperature for ensemble weighting.}

\item{cores}{Integer. Number of parallel workers (via \code{mirai}).}

\item{seed}{Optional integer passed to \code{mirai::daemons} for RNG reproducibility.}

\item{.progress}{Logical. Show progress bar?}
}
\value{
An object of class \code{"fastsvm_bag"} containing:
  \item{preds}{Numeric vector of aggregated predictions for \code{newdata}.}
  \item{weights}{Vector of weights assigned to each bootstrap model.}
  \item{chosen_kernels}{Vector of kernel names selected in each bootstrap.}
  \item{c_indices}{Vector of OOB C-indices for each bootstrap.}
  \item{mtry}{The mtry value used.}
}
\description{
Fits an ensemble of models using bootstrap aggregation (bagging) and 
computes predictions immediately using parallel workers.
}
\details{
\strong{Architecture:} 
This function adopts the exact "Train-and-Predict" strategy used in the 
'Random Survival Machines' reference script. It accepts \code{newdata} 
during training and computes predictions \strong{inside the parallel workers}. 
This ensures 100\% stability and numerical consistency.

\strong{Random Subspace (mtry):}
The \code{mtry} parameter allows for the random selection of a subset of 
covariates for each base learner, increasing diversity (similar to Random Forest).

\strong{Regression vs Ranking:}
By default (\code{rank_ratio = 0}), the model performs regression on the 
survival time.
}
\examples{
\dontrun{
if (reticulate::py_module_available("sksurv") && requireNamespace("mirai")) {
  library(FastSurvivalSVM)
  library(survival)
  
  # 1. Data Generation
  set.seed(123)
  df <- data_generation(n = 300, prop_cen = 0.3)
  
  idx <- sample(1:nrow(df), 200)
  train_df <- df[idx, ]
  test_df  <- df[-idx, ]
  
  # 2. Custom Kernel Factories
  make_wavelet <- function(A = 1) {
    force(A)
    function(x, z) {
      u <- (as.numeric(x) - as.numeric(z)) / A
      prod(cos(1.75 * u) * exp(-0.5 * u^2))
    }
  }
  
  make_poly <- function(degree = 3, coef0 = 1) {
    force(degree); force(coef0)
    function(x, z) (sum(as.numeric(x) * as.numeric(z)) + coef0)^degree
  }
  
  # 3. Kernel Specifications (rank_ratio=0 for Regression/Time)
  kernel_mix <- list(
    linear   = list(kernel="linear", alpha=1, rank_ratio=0, fit_intercept=TRUE),
    poly_std = list(kernel="poly", degree=2L, alpha=1, rank_ratio=0, fit_intercept=TRUE),
    wavelet  = list(kernel=make_wavelet(A=1), alpha=1, rank_ratio=0, fit_intercept=TRUE),
    poly_fun = list(kernel=make_poly(degree=2L), alpha=1, rank_ratio=0, fit_intercept=TRUE)
  )
  
  # 4. Run Bagging (Using mtry for Random Subspace)
  # We select 2 random features per model
  bag_results <- fastsvm_bagging(
    data       = train_df,
    newdata    = test_df,
    time_col   = "tempo",
    delta_col  = "cens",
    kernels    = kernel_mix,
    B          = 50,
    mtry       = 2, 
    cores      = parallel::detectCores(),
    seed       = 99,
    .progress  = TRUE
  )
  
  print(bag_results)
  
  # 5. Results
  cat("Preview of Predictions:\n")
  print(head(bag_results$preds))
  
  # Score 
  # Should give high concordance (e.g. > 0.80) matching reference script
  cidx <- score_fastsvm_bag(bag_results, test_df)
  cat(sprintf("Test C-index: \%.4f\n", cidx))
}
}

}
